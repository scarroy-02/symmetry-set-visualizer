<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symmetry Set Visualizer + Vineyard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Grotesk:wght@400;700&display=swap');
        
        :root {
            --bg-dark: #0a0a0f;
            --panel-bg: rgba(15, 15, 25, 0.95);
            --accent-blue: #4f8cff;
            --accent-green: #22c55e;
            --accent-red: #ef4444;
            --accent-purple: #a855f7;
            --accent-amber: #f59e0b;
            --border-glow: rgba(79, 140, 255, 0.3);
        }
        
        * { box-sizing: border-box; }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: var(--bg-dark); 
            color: #e0e0e0; 
            font-family: 'Space Grotesk', sans-serif;
        }
        
        canvas#mainCanvas { 
            position: absolute;
            top: 0; left: 0;
            width: 100vw; 
            height: 100vh; 
            cursor: crosshair; 
        }
        
        .panel {
            position: absolute;
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
            padding: 16px;
            z-index: 10;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .panel::-webkit-scrollbar { width: 4px; }
        .panel::-webkit-scrollbar-track { background: transparent; }
        .panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        .panel-left { top: 16px; left: 16px; width: 280px; }
        .panel-right { top: 16px; right: 16px; width: 240px; }
        .panel-vineyard { 
            bottom: 16px; 
            right: 16px; 
            width: 420px; 
            height: 380px;
            display: none;
            transition: all 0.3s ease;
        }
        .panel-vineyard.active { display: block; }
        .panel-vineyard.expanded {
            width: 800px;
            height: 680px;
        }
        
        .panel-persistence {
            bottom: 16px;
            left: 16px;
            width: 380px;
            height: 420px;
            display: none;
            transition: all 0.3s ease;
        }
        .panel-persistence.active { display: block; }
        .panel-persistence.expanded {
            width: 600px;
            height: 620px;
        }
        
        h2 { 
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem; 
            text-transform: uppercase; 
            letter-spacing: 0.15em;
            color: var(--accent-blue);
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(79,140,255,0.2);
        }
        
        h3 {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(255,255,255,0.5);
            margin: 16px 0 8px 0;
        }
        
        label { 
            display: block; 
            font-size: 0.75rem; 
            margin-bottom: 4px; 
            color: rgba(255,255,255,0.7);
        }
        
        input[type="range"] { 
            width: 100%; 
            cursor: pointer; 
            accent-color: var(--accent-blue);
            height: 4px;
        }
        
        .val-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--accent-blue);
            text-align: right;
        }
        
        .btn {
            width: 100%;
            padding: 10px 12px;
            font-size: 0.8rem;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .btn-primary { 
            background: linear-gradient(135deg, var(--accent-blue), #3b7aeb);
            color: white;
            box-shadow: 0 2px 8px rgba(79,140,255,0.3);
        }
        .btn-primary:hover { 
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79,140,255,0.4);
        }
        
        .btn-secondary {
            background: rgba(255,255,255,0.08);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.12); }
        
        .btn-vineyard {
            background: linear-gradient(135deg, var(--accent-purple), #8b5cf6);
            color: white;
            box-shadow: 0 2px 8px rgba(168,85,247,0.3);
        }
        .btn-vineyard:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(168,85,247,0.4);
        }
        
        .btn-vineyard.active {
            background: linear-gradient(135deg, #dc2626, #ef4444);
            box-shadow: 0 2px 8px rgba(239,68,68,0.3);
        }
        
        .btn-group { display: flex; gap: 6px; margin-bottom: 10px; }
        .btn-group .btn { flex: 1; padding: 8px; }
        
        select {
            width: 100%;
            background: rgba(255,255,255,0.08);
            color: white;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            font-family: inherit;
        }
        select:focus { outline: none; border-color: var(--accent-blue); }
        
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 0;
        }
        .toggle-row span { font-size: 0.8rem; color: rgba(255,255,255,0.8); }
        
        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--accent-blue);
        }
        
        .status {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            margin-bottom: 12px;
            color: var(--accent-amber);
            min-height: 2em;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.7rem;
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: 12px;
        }
        .legend-item { display: flex; align-items: center; gap: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; }
        
        .slider-group { margin-bottom: 12px; }
        
        .mode-indicator {
            display: inline-block;
            padding: 3px 8px;
            font-size: 0.65rem;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 700;
        }
        .mode-draw { background: var(--accent-blue); color: white; }
        .mode-vineyard { background: var(--accent-purple); color: white; }
        
        #vineyardPlot { width: 100%; height: 310px; transition: height 0.3s; }
        .panel-vineyard.expanded #vineyardPlot { height: 600px; }
        #persistencePlot { width: 100%; height: 350px; transition: height 0.3s; }
        .panel-persistence.expanded #persistencePlot { height: 540px; }
        
        .vineyard-controls {
            background: rgba(168,85,247,0.1);
            border: 1px solid rgba(168,85,247,0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }
        
        .vineyard-controls h3 {
            color: var(--accent-purple);
            margin-top: 0;
        }
        
        .anim-controls {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }
        .anim-controls .btn { flex: 1; }
        
        .instructions {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.5);
            line-height: 1.6;
        }
        .instructions div { margin-bottom: 4px; }
        .instructions .key { color: var(--accent-blue); }
    </style>
</head>
<body>

<canvas id="mainCanvas"></canvas>

<!-- Left Panel: Main Controls -->
<div class="panel panel-left">
    <h2>Symmetry + Vineyard</h2>
    
    <div class="status" id="status">Click to add points...</div>
    
    <div style="margin-bottom: 12px;">
        <label>Mode: <span class="mode-indicator" id="modeIndicator">Draw</span></label>
    </div>
    
    <div style="margin-bottom: 12px;">
        <label>Load Preset</label>
        <select id="presetSelect">
            <option value="" disabled selected>Select shape...</option>
            <option value="ellipse">Ellipse</option>
            <option value="astroid">Astroid</option>
            <option value="bean">Kidney Bean</option>
            <option value="cardioid">Cardioid</option>
        </select>
    </div>
    
    <!-- Curve Management -->
    <button id="newCurveBtn" class="btn" style="background: linear-gradient(135deg, #10b981, #059669); margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
        <span>+ New Curve</span>
        <span id="curveCountBadge" style="background: rgba(0,0,0,0.3); padding: 2px 8px; border-radius: 4px; font-size: 0.7rem;">1</span>
    </button>
    
    <div class="btn-group">
        <button class="btn btn-secondary" id="undoBtn">Undo</button>
        <button class="btn btn-secondary" id="clearBtn">Clear</button>
    </div>
    
    <div class="slider-group">
        <label>Resolution</label>
        <input type="range" id="resolution" min="500" max="40000" step="500" value="5000">
        <div class="val-display" id="resVal">5000</div>
    </div>
    
    <button class="btn btn-primary" id="computeBtn" style="margin-bottom: 12px;">Compute Symmetry Set</button>
    
    <!-- Focal Animation Section -->
    <div style="background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.2); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
        <h3 style="color: var(--accent-green); margin-top: 0;">◉ Focal Animation</h3>
        <div class="anim-controls">
            <button class="btn btn-secondary" id="focalPlayBtn" style="background: linear-gradient(135deg, #22c55e, #16a34a);">▶ Play</button>
            <button class="btn btn-secondary" id="focalStopBtn">◼ Stop</button>
        </div>
        <div class="slider-group" style="margin-top: 8px;">
            <label>Position</label>
            <input type="range" id="focalAnimSlider" min="0" max="1000" value="0" style="accent-color: #22c55e;">
        </div>
    </div>
    
    <!-- Vineyard Section -->
    <div class="vineyard-controls">
        <h3>⬡ Vineyard Mode</h3>
        <button class="btn btn-vineyard" id="vineyardModeBtn">Place Center Point</button>
        
        <div class="slider-group" style="margin-top: 12px;">
            <label>Circle Radius</label>
            <input type="range" id="vineyardRadius" min="0.001" max="10" step="0.01" value="1">
            <div class="val-display" id="radiusVal">1.0</div>
        </div>
        
        <div class="slider-group">
            <label>Sample Points (per circle)</label>
            <input type="range" id="vineyardSamples" min="8" max="300" step="4" value="64">
            <div class="val-display" id="samplesVal">64</div>
        </div>
        
        <button class="btn btn-primary" id="computeVineyardBtn" style="margin-top: 8px;">Compute Vineyard</button>
        
        <div class="anim-controls">
            <button class="btn btn-secondary" id="playVineyardBtn">▶ Play</button>
            <button class="btn btn-secondary" id="stopVineyardBtn">◼ Stop</button>
        </div>
        
        <div class="slider-group" style="margin-top: 8px;">
            <label>Animation Position</label>
            <input type="range" id="vineyardAnimSlider" min="0" max="1000" value="0">
        </div>
        
        <!-- Radius Sweep Section -->
        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(168,85,247,0.3);">
            <h3 style="color: #c084fc; margin-top: 0;">◎ Radius Sweep</h3>
            
            <div style="display: flex; gap: 8px;">
                <div class="slider-group" style="flex: 1; margin-bottom: 8px;">
                    <label>Start R</label>
                    <input type="range" id="radiusStart" min="0.01" max="10" step="0.01" value="0.5">
                    <div class="val-display" id="radiusStartVal">0.5</div>
                </div>
                <div class="slider-group" style="flex: 1; margin-bottom: 8px;">
                    <label>End R</label>
                    <input type="range" id="radiusEnd" min="0.01" max="10" step="0.01" value="5">
                    <div class="val-display" id="radiusEndVal">5.0</div>
                </div>
            </div>
            
            <div class="slider-group">
                <label>Radius Steps</label>
                <input type="range" id="radiusSteps" min="5" max="100" step="5" value="30">
                <div class="val-display" id="radiusStepsVal">30</div>
            </div>
            
            <button class="btn" id="computeRadiusSweepBtn" style="background: linear-gradient(135deg, #c084fc, #a855f7); margin-top: 8px;">Compute Radius Sweep</button>
            
            <div class="anim-controls" style="margin-top: 8px;">
                <button class="btn btn-secondary" id="playRadiusSweepBtn">▶ Play Sweep</button>
                <button class="btn btn-secondary" id="stopRadiusSweepBtn">◼ Stop</button>
            </div>
            
            <div class="slider-group" style="margin-top: 8px;">
                <label>Sweep Position</label>
                <input type="range" id="radiusSweepSlider" min="0" max="1000" value="0" style="accent-color: #c084fc;">
                <div class="val-display" id="currentSweepRadius">R: --</div>
            </div>
        </div>
    </div>
    
    <button class="btn btn-secondary" id="resetViewBtn" style="margin-top: 12px;">Reset View</button>
    
    <div class="legend">
        <div class="legend-item"><span class="dot" style="background: var(--accent-blue);"></span> Curve</div>
        <div class="legend-item"><span class="dot" style="background: var(--accent-green);"></span> Focal</div>
        <div class="legend-item"><span class="dot" style="background: var(--accent-red);"></span> Symmetry</div>
        <div class="legend-item"><span class="dot" style="background: var(--accent-purple);"></span> Vineyard</div>
    </div>
</div>

<!-- Right Panel: Visibility & Instructions -->
<div class="panel panel-right">
    <h2>Display</h2>
    
    <div class="toggle-row">
        <span>Curve</span>
        <input type="checkbox" id="showCurve" checked>
    </div>
    <div class="toggle-row">
        <span>Control Points</span>
        <input type="checkbox" id="showControls" checked>
    </div>
    <div class="toggle-row">
        <span>Focal Set</span>
        <input type="checkbox" id="showFocal" checked>
    </div>
    <div class="toggle-row">
        <span>Symmetry Set</span>
        <input type="checkbox" id="showSS" checked>
    </div>
    <div class="toggle-row">
        <span>Vineyard Circle</span>
        <input type="checkbox" id="showVineyardCircle" checked>
    </div>
    <div class="toggle-row">
        <span>Vineyard 3D Plot</span>
        <input type="checkbox" id="showVineyardPlot" checked>
    </div>
    <div class="toggle-row">
        <span>Persistence Diagram</span>
        <input type="checkbox" id="showPD" checked>
    </div>
    
    <h3>Instructions</h3>
    <div class="instructions">
        <div><span class="key">Left Click</span> Add/Select Point</div>
        <div><span class="key">Drag Point</span> Move Point</div>
        <div><span class="key">Right Drag</span> Pan View</div>
        <div><span class="key">Scroll</span> Zoom</div>
        <div><span class="key">Del</span> Delete Point</div>
        <div><span class="key">Ctrl+Z</span> Undo</div>
        <div style="margin-top: 8px; color: var(--accent-purple);">
            <span class="key">Vineyard Mode</span> Click to place center, then compute
        </div>
    </div>
</div>

<!-- Vineyard 3D Plot Panel -->
<div class="panel panel-vineyard" id="vineyardPanel">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <h2 style="margin: 0; border: none; padding: 0;">Vineyard Plot</h2>
        <button id="expandVineyardBtn" class="btn btn-secondary" style="width: auto; padding: 4px 10px; font-size: 0.7rem;">⤢ Expand</button>
    </div>
    <div id="vineyardPlot"></div>
</div>

<!-- Persistence Diagram Panel -->
<div class="panel panel-persistence" id="persistencePanel">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <h2 style="margin: 0; border: none; padding: 0;">Persistence Diagram</h2>
        <button id="expandPDBtn" class="btn btn-secondary" style="width: auto; padding: 4px 10px; font-size: 0.7rem;">⤢ Expand</button>
    </div>
    <div id="persistencePlot"></div>
</div>

<script>
// ========== Math Classes ==========
class Point {
    constructor(x, y) { this.x = x; this.y = y; }
    add(o) { return new Point(this.x + o.x, this.y + o.y); }
    sub(o) { return new Point(this.x - o.x, this.y - o.y); }
    mult(s) { return new Point(this.x * s, this.y * s); }
    dot(o) { return this.x * o.x + this.y * o.y; }
    norm() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { const n = this.norm(); return n < 1e-15 ? new Point(0,0) : this.mult(1/n); }
}

// ========== Union-Find for Persistence ==========
class UnionFind {
    constructor(n, birthValues) {
        this.parent = Array.from({length: n}, (_, i) => i);
        this.birth = [...birthValues];
    }
    
    find(i) {
        const path = [];
        while (this.parent[i] !== i) {
            path.push(i);
            i = this.parent[i];
        }
        for (const node of path) {
            this.parent[node] = i;
        }
        return i;
    }
    
    union(i, j, currentValue) {
        const rootI = this.find(i);
        const rootJ = this.find(j);
        
        if (rootI !== rootJ) {
            let elder, younger;
            if (this.birth[rootI] < this.birth[rootJ]) {
                elder = rootI; younger = rootJ;
            } else if (this.birth[rootJ] < this.birth[rootI]) {
                elder = rootJ; younger = rootI;
            } else {
                elder = rootI < rootJ ? rootI : rootJ;
                younger = rootI < rootJ ? rootJ : rootI;
            }
            
            const deathValue = currentValue;
            const persistencePair = [this.birth[younger], deathValue];
            this.parent[younger] = elder;
            return { pair: persistencePair, isH1: false };
        } else {
            return { pair: [currentValue, null], isH1: true };
        }
    }
}

// ========== Global State ==========
const SAMPLING_DENSITY = 30000;
const LAMBDA_MAX = 5000.0;
const R_MAX = 100000.0;

// Multi-curve support
let curves = [[]];
let activeCurveIdx = 0;

let cachedCurveData = null;
let cachedSSData = null;
let ssResolution = 5000;

// Interaction
let dragInfo = null;  // { cIdx, pIdx }
let hoverInfo = null; // { cIdx, pIdx }
let selectedInfo = null; // { cIdx, pIdx }
let view = { x: 0, y: 0, scale: 50 };

let isInteractionActive = false;
let interactionType = null;
let mouseStart = { x: 0, y: 0 };
let viewStart = { x: 0, y: 0 };

// History
const MAX_HISTORY = 50;
let historyStack = [];

// Vineyard State
let vineyardMode = false;
let vineyardCenter = null;
let vineyardRadius = 1.0;
let vineyardSamples = 64;
let vineyardCenters = [];
let vineyardData = null;  // { h0: [], h1: [] }
let vineyardAnimIdx = 0;
let vineyardAnimPlaying = false;
let currentPersistence = null;
let vineyardMaxVal = 1; // Global max value for consistent axis ranges
let vineyardDragging = false; // For dragging vineyard center during animation

// Focal Animation State
let focalAnimPlaying = false;
let focalAnimIdx = 0;

// Radius Sweep State
let radiusSweepData = null;  // { radii: [], allH0: [], allH1: [], infinityY: number }
let radiusSweepPlaying = false;
let radiusSweepIdx = 0;
let radiusStart = 0.5;
let radiusEnd = 5.0;
let radiusSteps = 30;

// Canvas
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');

// ========== History ==========
function saveState() {
    const state = {
        curves: curves.map(curve => curve.map(p => new Point(p.x, p.y))),
        activeCurveIdx: activeCurveIdx,
        vineyardCenter: vineyardCenter ? new Point(vineyardCenter.x, vineyardCenter.y) : null
    };
    historyStack.push(state);
    if (historyStack.length > MAX_HISTORY) historyStack.shift();
}

function performUndo() {
    if (historyStack.length === 0) return;
    const state = historyStack.pop();
    curves = state.curves;
    activeCurveIdx = state.activeCurveIdx;
    vineyardCenter = state.vineyardCenter;
    
    // Validate active index
    if (activeCurveIdx >= curves.length) activeCurveIdx = curves.length - 1;
    if (activeCurveIdx < 0) { activeCurveIdx = 0; curves = [[]]; }
    
    selectedInfo = null;
    updateStatus();
    updateUI();
    triggerComputation(true);
}

// ========== B-Spline ==========
function solveControlPoints(points) {
    const n = points.length;
    if (n < 3) return points;

    const rhsX = new Float64Array(n);
    const rhsY = new Float64Array(n);
    
    for(let i=0; i<n; i++) {
        rhsX[i] = 6.0 * points[i].x;
        rhsY[i] = 6.0 * points[i].y;
    }

    const solX = new Float64Array(n);
    const solY = new Float64Array(n);
    
    for(let i=0; i<n; i++) { solX[i] = points[i].x; solY[i] = points[i].y; }

    for(let iter=0; iter<20; iter++) {
        for(let i=0; i<n; i++) {
            const prev = (i === 0) ? n - 1 : i - 1;
            const next = (i === n - 1) ? 0 : i + 1;
            solX[i] = (rhsX[i] - solX[prev] - solX[next]) * 0.25;
            solY[i] = (rhsY[i] - solY[prev] - solY[next]) * 0.25;
        }
    }

    return Array.from({length: n}, (_, i) => new Point(solX[i], solY[i]));
}

function bSplineEval(p0, p1, p2, p3, t) {
    const t2 = t*t, t3 = t2*t;
    const b0 = (-t3 + 3*t2 - 3*t + 1)/6;
    const b1 = (3*t3 - 6*t2 + 4)/6;
    const b2 = (-3*t3 + 3*t2 + 3*t + 1)/6;
    const b3 = t3/6;
    return new Point(p0.x*b0 + p1.x*b1 + p2.x*b2 + p3.x*b3, p0.y*b0 + p1.y*b1 + p2.y*b2 + p3.y*b3);
}

function bSplineDeriv1(p0, p1, p2, p3, t) {
    const t2 = t*t;
    const d0 = (-3*t2 + 6*t - 3)/6;
    const d1 = (9*t2 - 12*t)/6;
    const d2 = (-9*t2 + 6*t + 3)/6;
    const d3 = (3*t2)/6;
    return new Point(p0.x*d0 + p1.x*d1 + p2.x*d2 + p3.x*d3, p0.y*d0 + p1.y*d1 + p2.y*d2 + p3.y*d3);
}

function bSplineDeriv2(p0, p1, p2, p3, t) {
    const dd0 = (-6*t + 6)/6;
    const dd1 = (18*t - 12)/6;
    const dd2 = (-18*t + 6)/6;
    const dd3 = (6*t)/6;
    return new Point(p0.x*dd0 + p1.x*dd1 + p2.x*dd2 + p3.x*dd3, p0.y*dd0 + p1.y*dd1 + p2.y*dd2 + p3.y*dd3);
}

function computeSplineData() {
    const allData = [];
    
    // Process each curve independently
    for (let cIdx = 0; cIdx < curves.length; cIdx++) {
        const pts = curves[cIdx];
        if (pts.length < 3) continue;

        const C = solveControlPoints(pts);
        const n = C.length;
        const drawC = [C[n-1], ...C, C[0], C[1]];

        const numSegments = pts.length;
        // Split total density budget among curves
        const budget = Math.floor(SAMPLING_DENSITY / Math.max(1, curves.length));
        const pointsPerSeg = Math.floor(budget / Math.max(1, numSegments));

        for (let i = 0; i < numSegments; i++) {
            const p0 = drawC[i], p1 = drawC[i+1], p2 = drawC[i+2], p3 = drawC[i+3];

            for (let j = 0; j < pointsPerSeg; j++) {
                const t = j / pointsPerSeg;
                const P = bSplineEval(p0, p1, p2, p3, t);
                const d1 = bSplineDeriv1(p0, p1, p2, p3, t);
                const d2 = bSplineDeriv2(p0, p1, p2, p3, t);
                
                const velSq = d1.dot(d1);
                if (velSq < 1e-15) continue;

                const T = d1.normalize();
                const N = new Point(-T.y, T.x);
                const k = (d1.x * d2.y - d1.y * d2.x) / Math.pow(velSq, 1.5);

                allData.push({ p: P, T: T, N: N, curvature: k, curveId: cIdx });
            }
        }
    }
    return allData;
}

// ========== Symmetry Set ==========
function computeSymmetrySet(data, resolutionLimit) {
    if (!data || data.length === 0) return [];
    
    const centers = [];
    const step = Math.max(1, Math.floor(data.length / resolutionLimit));
    const activeIndices = [];
    for (let i = 0; i < data.length; i += step) activeIndices.push(i);
    
    const n = activeIndices.length;
    const Px = new Float64Array(n), Py = new Float64Array(n);
    const Tx = new Float64Array(n), Ty = new Float64Array(n);
    const Nx = new Float64Array(n), Ny = new Float64Array(n);
    const Id = new Int32Array(n); // Store curve ID
    
    for(let k=0; k<n; k++) {
        const idx = activeIndices[k];
        Px[k] = data[idx].p.x; Py[k] = data[idx].p.y;
        Tx[k] = data[idx].T.x; Ty[k] = data[idx].T.y;
        Nx[k] = data[idx].N.x; Ny[k] = data[idx].N.y;
        Id[k] = data[idx].curveId || 0;
    }

    const minChordSq = 0.3 * 0.3;
    const radiusTol = 0.15;

    for (let i = 0; i < n; i++) {
        const px = Px[i], py = Py[i], tx = Tx[i], ty = Ty[i], nx = Nx[i], ny = Ny[i];
        const id1 = Id[i];
        let prev_check1 = NaN, prev_check2 = NaN;

        for (let j = i + 1; j < n; j++) {
            const dx = px - Px[j], dy = py - Py[j];
            
            // If on same curve, check distance. If different curves, no min distance needed.
            if (id1 === Id[j]) {
                if (dx*dx + dy*dy < minChordSq) continue;
            }

            const t2x = Tx[j], t2y = Ty[j];
            const dotT = tx*t2x + ty*t2y;

            if (dotT > -0.9999) {
                const eq1 = dx * (tx + t2x) + dy * (ty + t2y);
                if (!isNaN(prev_check1) && prev_check1 * eq1 < 0) {
                    const nsx = nx + Nx[j], nsy = ny + Ny[j];
                    const den = nsx*nsx + nsy*nsy;
                    if (den > 1e-10) {
                        const lam = (-dx*nsx - dy*nsy) / den;
                        if (Math.abs(lam) < LAMBDA_MAX) {
                            const cx = px + nx*lam, cy = py + ny*lam;
                            const r1 = Math.abs(lam);
                            const r2 = Math.sqrt((cx-Px[j])**2 + (cy-Py[j])**2);
                            if (Math.abs(r1 - r2) < r1*radiusTol + 0.1) centers.push({x:cx, y:cy});
                        }
                    }
                }
                prev_check1 = eq1;
            } else prev_check1 = NaN;

            if (dotT < 0.9999) {
                const eq2 = dx * (tx - t2x) + dy * (ty - t2y);
                if (!isNaN(prev_check2) && prev_check2 * eq2 < 0) {
                    const nsx = nx - Nx[j], nsy = ny - Ny[j];
                    const den = nsx*nsx + nsy*nsy;
                    if (den > 1e-10) {
                        const lam = (-dx*nsx - dy*nsy) / den;
                        if (Math.abs(lam) < LAMBDA_MAX) {
                            const cx = px + nx*lam, cy = py + ny*lam;
                            const r1 = Math.abs(lam);
                            const r2 = Math.sqrt((cx-Px[j])**2 + (cy-Py[j])**2);
                            if (Math.abs(r1 - r2) < r1*radiusTol + 0.1) centers.push({x:cx, y:cy});
                        }
                    }
                }
                prev_check2 = eq2;
            } else prev_check2 = NaN;
        }
    }
    return centers;
}

// ========== Persistent Homology ==========
function computePersistence(center, curveData) {
    if (!curveData || curveData.length === 0) return { h0: [], h1: [] };
    
    const n = curveData.length;
    
    // Compute distances from center to each curve point
    const dists = curveData.map(d => ((d.p.x - center.x)**2 + (d.p.y - center.y)**2));
    
    // Build neighbor structure respecting curve boundaries
    // First, group points by curveId and track their global indices
    const curveGroups = new Map(); // curveId -> array of global indices
    for (let i = 0; i < n; i++) {
        const cId = curveData[i].curveId || 0;
        if (!curveGroups.has(cId)) {
            curveGroups.set(cId, []);
        }
        curveGroups.get(cId).push(i);
    }
    
    // Build neighbor map: for each point, its neighbors within its curve (cyclic)
    const neighbors = new Array(n);
    for (let i = 0; i < n; i++) {
        neighbors[i] = [];
    }
    
    for (const [cId, indices] of curveGroups) {
        const len = indices.length;
        for (let j = 0; j < len; j++) {
            const globalIdx = indices[j];
            const prevIdx = indices[(j - 1 + len) % len];
            const nextIdx = indices[(j + 1) % len];
            neighbors[globalIdx] = [prevIdx, nextIdx];
        }
    }
    
    // Sort indices by distance
    const sortedIndices = Array.from({length: n}, (_, i) => i)
        .sort((a, b) => dists[a] - dists[b]);
    
    const uf = new UnionFind(n, dists);
    const h0Pairs = [];
    const h1Pairs = [];
    const processed = new Array(n).fill(false);
    
    for (const v of sortedIndices) {
        const currentR = dists[v];
        processed[v] = true;
        
        // Check neighbors within the same curve
        for (const u of neighbors[v]) {
            if (processed[u]) {
                const result = uf.union(u, v, currentR);
                if (result.isH1) {
                    h1Pairs.push([currentR, Infinity]);
                } else {
                    if (result.pair[0] !== result.pair[1]) {
                        h0Pairs.push(result.pair);
                    }
                }
            }
        }
    }
    
    // Add the infinite H0 component (one for each connected component at the end)
    // Find all unique roots
    const roots = new Set();
    for (let i = 0; i < n; i++) {
        roots.add(uf.find(i));
    }
    
    // Add infinite H0 for each final component
    for (const root of roots) {
        h0Pairs.push([uf.birth[root], Infinity]);
    }
    
    return { h0: h0Pairs, h1: h1Pairs };
}

function computeVineyardForRadius(centerPoint, radius, numSamples, curveData) {
    // Generate circle of centers
    const centers = [];
    for (let i = 0; i < numSamples; i++) {
        const theta = (i / numSamples) * Math.PI * 2;
        centers.push(new Point(
            centerPoint.x + radius * Math.cos(theta),
            centerPoint.y + radius * Math.sin(theta)
        ));
    }
    
    // Compute max possible distance for infinity representation
    let maxDist = 0;
    for (const center of centers) {
        for (const d of curveData) {
            const dx = d.p.x - center.x;
            const dy = d.p.y - center.y;
            const dist = (dx*dx + dy*dy);
            if (dist > maxDist) maxDist = dist;
        }
    }
    
    const infinityY = maxDist * 1.15;
    
    // Compute persistence for each center
    const h0 = [];
    const h1 = [];
    
    for (let i = 0; i < centers.length; i++) {
        const center = centers[i];
        const pers = computePersistence(center, curveData);
        
        for (const [b, d] of pers.h0) {
            h0.push({
                birth: b,
                death: d === Infinity ? infinityY : d,
                centerIdx: i,
                isInfinite: d === Infinity
            });
        }
        for (const [b, d] of pers.h1) {
            h1.push({
                birth: b,
                death: d === Infinity ? infinityY : d,
                centerIdx: i,
                isInfinite: d === Infinity
            });
        }
    }
    
    return {
        h0: h0,
        h1: h1,
        centers: centers,
        infinityY: infinityY,
        radius: radius
    };
}

function computeVineyard() {
    if (!vineyardCenter || !cachedCurveData || cachedCurveData.length === 0) {
        updateStatus('Need curve and center point!');
        return;
    }
    
    updateStatus('Computing vineyard...');
    
    const result = computeVineyardForRadius(vineyardCenter, vineyardRadius, vineyardSamples, cachedCurveData);
    
    vineyardCenters = result.centers;
    vineyardData = {
        h0: result.h0,
        h1: result.h1,
        infinityY: result.infinityY
    };
    vineyardMaxVal = result.infinityY;
    
    updateStatus(`Vineyard computed! ${vineyardData.h0.length + vineyardData.h1.length} points`);
    
    // Update plots
    updateVineyardPlot();
    updatePersistenceDiagram(0);
    
    // Show panels
    document.getElementById('vineyardPanel').classList.add('active');
    document.getElementById('persistencePanel').classList.add('active');
    
    draw();
}

function updateVineyardPlot() {
    if (!vineyardData) return;
    
    const h0 = vineyardData.h0;
    const h1 = vineyardData.h1;
    const maxVal = vineyardMaxVal;
    
    const traceH0 = {
        x: h0.map(d => d.birth),
        y: h0.map(d => d.death),
        z: h0.map(d => d.centerIdx),
        mode: 'markers',
        type: 'scatter3d',
        name: 'H₀',
        marker: {
            size: 3,
            color: '#ef4444',
            opacity: 0.7
        }
    };
    
    const traceH1 = {
        x: h1.map(d => d.birth),
        y: h1.map(d => d.death),
        z: h1.map(d => d.centerIdx),
        mode: 'markers',
        type: 'scatter3d',
        name: 'H₁',
        marker: {
            size: 3,
            color: '#3b82f6',
            opacity: 0.7,
            symbol: 'diamond'
        }
    };
    
    // Add current position indicator
    const currentZ = vineyardAnimIdx;
    const currentH0 = h0.filter(d => d.centerIdx === currentZ);
    const currentH1 = h1.filter(d => d.centerIdx === currentZ);
    
    const currentTrace = {
        x: [...currentH0.map(d => d.birth), ...currentH1.map(d => d.birth)],
        y: [...currentH0.map(d => d.death), ...currentH1.map(d => d.death)],
        z: [...currentH0.map(d => d.centerIdx), ...currentH1.map(d => d.centerIdx)],
        mode: 'markers',
        type: 'scatter3d',
        name: 'Current',
        marker: {
            size: 6,
            color: '#fbbf24',
            opacity: 1,
            line: { color: 'white', width: 1 }
        }
    };
    
    // Diagonal plane (birth = death) as mesh
    const diagPoints = {
        x: [0, maxVal, maxVal, 0],
        y: [0, maxVal, maxVal, 0],
        z: [0, 0, vineyardSamples - 1, vineyardSamples - 1],
        i: [0, 0],
        j: [1, 2],
        k: [2, 3],
        type: 'mesh3d',
        name: 'Diagonal',
        color: 'rgba(100,100,100,0.15)',
        showscale: false,
        hoverinfo: 'skip'
    };
    
    const layout = {
        scene: {
            xaxis: { 
                title: { text: 'Birth', font: { size: 11 } },
                color: '#888', 
                gridcolor: '#333',
                range: [0, maxVal],
                dtick: maxVal / 4,
                showspikes: false
            },
            yaxis: { 
                title: { text: 'Death', font: { size: 11 } },
                color: '#888', 
                gridcolor: '#333',
                range: [0, maxVal],
                dtick: maxVal / 4,
                showspikes: false
            },
            zaxis: { 
                title: { text: 'Center Index', font: { size: 11 } },
                color: '#888', 
                gridcolor: '#333',
                range: [0, vineyardSamples - 1],
                showspikes: false
            },
            bgcolor: 'rgba(0,0,0,0)',
            camera: { eye: { x: 1.6, y: 1.6, z: 1.0 } },
            aspectmode: 'manual',
            aspectratio: { x: 1, y: 1, z: 0.8 }
        },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        margin: { l: 0, r: 0, t: 10, b: 0 },
        legend: {
            x: 0, y: 1,
            font: { color: '#ccc', size: 10 },
            bgcolor: 'rgba(0,0,0,0.5)'
        },
        showlegend: true
    };
    
    Plotly.newPlot('vineyardPlot', [diagPoints, traceH0, traceH1, currentTrace], layout, {
        displayModeBar: false,
        responsive: true
    });
}

function updatePersistenceDiagram(centerIdx) {
    if (!vineyardData || !vineyardCenters[centerIdx]) return;
    
    const h0 = vineyardData.h0.filter(d => d.centerIdx === centerIdx);
    const h1 = vineyardData.h1.filter(d => d.centerIdx === centerIdx);
    
    currentPersistence = { h0, h1 };
    
    // Use global max value for consistent scale across all centers
    const maxVal = vineyardMaxVal;
    
    const traceH0 = {
        x: h0.map(d => d.birth),
        y: h0.map(d => d.death),
        mode: 'markers',
        type: 'scatter',
        name: 'H₀',
        marker: { size: 10, color: '#ef4444', symbol: 'circle' }
    };
    
    const traceH1 = {
        x: h1.map(d => d.birth),
        y: h1.map(d => d.death),
        mode: 'markers',
        type: 'scatter',
        name: 'H₁',
        marker: { size: 10, color: '#3b82f6', symbol: 'triangle-up' }
    };
    
    const diagonal = {
        x: [0, maxVal],
        y: [0, maxVal],
        mode: 'lines',
        type: 'scatter',
        name: 'Diagonal',
        line: { color: '#555', dash: 'dash', width: 1 },
        showlegend: false,
        hoverinfo: 'skip'
    };
    
    // Infinity line indicator
    const infinityY = vineyardData.infinityY;
    const infinityLine = {
        x: [0, maxVal],
        y: [infinityY, infinityY],
        mode: 'lines',
        type: 'scatter',
        name: '∞',
        line: { color: '#888', dash: 'dot', width: 1 },
        showlegend: false,
        hoverinfo: 'skip'
    };
    
    const layout = {
        xaxis: { 
            title: { text: 'Birth', font: { size: 12, color: '#aaa' }, standoff: 10 },
            color: '#888', 
            gridcolor: '#333',
            range: [-maxVal * 0.02, maxVal * 1.02],
            zeroline: true,
            zerolinecolor: '#666',
            zerolinewidth: 2,
            showline: true,
            linecolor: '#666',
            linewidth: 1,
            mirror: false,
            tickmode: 'auto',
            nticks: 8
        },
        yaxis: { 
            title: { text: 'Death', font: { size: 12, color: '#aaa' }, standoff: 10 },
            color: '#888', 
            gridcolor: '#333',
            range: [-maxVal * 0.02, maxVal * 1.02],
            zeroline: true,
            zerolinecolor: '#666',
            zerolinewidth: 2,
            showline: true,
            linecolor: '#666',
            linewidth: 1,
            mirror: false,
            scaleanchor: 'x',
            scaleratio: 1,
            tickmode: 'auto',
            nticks: 8
        },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(10,10,15,0.5)',
        margin: { l: 60, r: 20, t: 40, b: 55 },
        legend: {
            x: 0.75, y: 0.15,
            font: { color: '#ccc', size: 11 },
            bgcolor: 'rgba(0,0,0,0.6)',
            bordercolor: 'rgba(255,255,255,0.1)',
            borderwidth: 1
        },
        showlegend: true,
        title: {
            text: `Persistence Diagram — Center ${centerIdx}`,
            font: { color: '#aaa', size: 13 },
            x: 0.5,
            xanchor: 'center'
        },
        annotations: [{
            x: maxVal * 0.02,
            y: infinityY,
            xref: 'x',
            yref: 'y',
            text: '∞',
            showarrow: false,
            font: { color: '#888', size: 12 },
            xanchor: 'left',
            yanchor: 'middle'
        }]
    };
    
    Plotly.newPlot('persistencePlot', [diagonal, infinityLine, traceH0, traceH1], layout, {
        displayModeBar: false,
        responsive: true
    });
}

// ========== Presets ==========
function loadPreset(type) {
    saveState();
    curves = [[]];
    activeCurveIdx = 0;
    view.x = 0; view.y = 0; view.scale = 50;
    
    let count = 8;
    
    if (type === 'ellipse') {
        const a = 4.0, b = 2.5;
        for(let i=0; i<count; i++) {
            const t = (i/count) * Math.PI * 2;
            curves[0].push(new Point(a*Math.cos(t), b*Math.sin(t)));
        }
    } else if (type === 'astroid') {
        count = 12;
        const r = 3.5;
        for(let i=0; i<count; i++) {
            const t = (i/count) * Math.PI * 2;
            curves[0].push(new Point(r * Math.pow(Math.cos(t), 3), r * Math.pow(Math.sin(t), 3)));
        }
    } else if (type === 'bean') {
        count = 10;
        for(let i=0; i<count; i++) {
            const t = (i/count) * Math.PI * 2;
            const r = 2.0 + Math.cos(t) + Math.pow(Math.sin(t), 2);
            curves[0].push(new Point(r*Math.cos(t), r*Math.sin(t)));
        }
    } else if (type === 'cardioid') {
        count = 10;
        const a = 1.5;
        for(let i=0; i<count; i++) {
            const t = (i/count) * Math.PI * 2;
            const r = 2*a*(1 + Math.cos(t));
            curves[0].push(new Point(r*Math.cos(t), r*Math.sin(t)));
        }
    }
    
    updateUI();
    triggerComputation(true);
    document.getElementById('presetSelect').value = "";
}

// ========== UI Helpers ==========
function updateStatus(msg) {
    const pts = curves[activeCurveIdx] || [];
    document.getElementById('status').innerText = msg || `Curve ${activeCurveIdx}: ${pts.length} pts`;
}

function updateUI() {
    document.getElementById('curveCountBadge').innerText = curves.length;
}

function updateModeIndicator() {
    const indicator = document.getElementById('modeIndicator');
    if (vineyardMode) {
        indicator.innerText = 'Vineyard';
        indicator.className = 'mode-indicator mode-vineyard';
    } else {
        indicator.innerText = 'Draw';
        indicator.className = 'mode-indicator mode-draw';
    }
}

function screenToWorld(sx, sy) {
    const cx = canvas.width/2 + view.x;
    const cy = canvas.height/2 + view.y;
    return new Point((sx - cx) / view.scale, -(sy - cy) / view.scale);
}

function worldToScreen(p) {
    const cx = canvas.width/2 + view.x;
    const cy = canvas.height/2 + view.y;
    return { x: cx + p.x * view.scale, y: cy - p.y * view.scale };
}

function findHitControlPoint(sx, sy) {
    const threshSq = 144;
    // Iterate all curves
    for(let c=0; c<curves.length; c++) {
        for(let i=0; i<curves[c].length; i++) {
            const sp = worldToScreen(curves[c][i]);
            const dx = sp.x - sx, dy = sp.y - sy;
            if (dx*dx + dy*dy < threshSq) return { cIdx: c, pIdx: i };
        }
    }
    return null;
}

function pointToSegmentDistSq(p, v, w) {
    const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
    if (l2 === 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const projX = v.x + t * (w.x - v.x);
    const projY = v.y + t * (w.y - v.y);
    return (p.x - projX)**2 + (p.y - projY)**2;
}

function insertPointSmart(newPt) {
    // Always insert into ACTIVE curve
    const pts = curves[activeCurveIdx];
    
    if (pts.length < 3) {
        pts.push(newPt);
        selectedInfo = { cIdx: activeCurveIdx, pIdx: pts.length - 1 };
        return;
    }

    let bestIdx = -1, minDistSq = Infinity;
    for (let i = 0; i < pts.length; i++) {
        const p1 = pts[i];
        const p2 = pts[(i + 1) % pts.length];
        const distSq = pointToSegmentDistSq(newPt, p1, p2);
        if (distSq < minDistSq) { minDistSq = distSq; bestIdx = i; }
    }
    
    pts.splice(bestIdx + 1, 0, newPt);
    selectedInfo = { cIdx: activeCurveIdx, pIdx: bestIdx + 1 };
}

// ========== Event Handlers ==========
canvas.addEventListener('mousedown', e => {
    e.preventDefault();
    const mousePos = screenToWorld(e.clientX, e.clientY);
    
    mouseStart = { x: e.clientX, y: e.clientY };
    viewStart = { x: view.x, y: view.y };
    isInteractionActive = true;

    // Right click = pan
    if (e.button === 2 || e.altKey) {
        interactionType = 'PAN';
        canvas.style.cursor = 'grabbing';
        return;
    }

    if (e.button === 0) {
        // Vineyard mode: place center
        if (vineyardMode) {
            saveState();
            vineyardCenter = mousePos;
            vineyardMode = false;
            updateModeIndicator();
            document.getElementById('vineyardModeBtn').classList.remove('active');
            document.getElementById('vineyardModeBtn').innerText = 'Place Center Point';
            updateStatus('Center placed! Click "Compute Vineyard"');
            isInteractionActive = false;
            draw();
            return;
        }
        
        // Check if clicking on vineyard center (allow dragging even during animation)
        if (findHitVineyardCenter(e.clientX, e.clientY)) {
            vineyardDragging = true;
            interactionType = 'DRAG_VINEYARD';
            canvas.style.cursor = 'grabbing';
            return;
        }
        
        // Normal mode: check for point hit
        const hit = findHitControlPoint(e.clientX, e.clientY);
        if (hit !== null) {
            selectedInfo = { ...hit };
            activeCurveIdx = hit.cIdx; // Switch active curve on selection
            saveState();
            dragInfo = hit;
            interactionType = 'DRAG_POINT';
            draw();
            return;
        }
        
        interactionType = 'POTENTIAL_PAN';
    }
});

canvas.addEventListener('mousemove', e => {
    const dx = e.clientX - mouseStart.x;
    const dy = e.clientY - mouseStart.y;
    const distSq = dx*dx + dy*dy;

    if (interactionType === 'DRAG_VINEYARD' && vineyardDragging) {
        const p = screenToWorld(e.clientX, e.clientY);
        vineyardCenter = p;
        // Update vineyard centers for animation
        if (vineyardCenters.length > 0) {
            vineyardCenters = [];
            for (let i = 0; i < vineyardSamples; i++) {
                const theta = (i / vineyardSamples) * Math.PI * 2;
                vineyardCenters.push(new Point(
                    vineyardCenter.x + vineyardRadius * Math.cos(theta),
                    vineyardCenter.y + vineyardRadius * Math.sin(theta)
                ));
            }
        }
        draw();
        return;
    }

    if (interactionType === 'DRAG_POINT' && dragInfo) {
        const p = screenToWorld(e.clientX, e.clientY);
        curves[dragInfo.cIdx][dragInfo.pIdx] = p;
        triggerComputation(false);
        return;
    }

    if (interactionType === 'PAN') {
        view.x = viewStart.x + dx;
        view.y = viewStart.y + dy;
        draw();
        return;
    }

    if (interactionType === 'POTENTIAL_PAN' && distSq > 25) {
        interactionType = 'PAN';
        canvas.style.cursor = 'grabbing';
        return;
    }

    // Hover
    if (!isInteractionActive) {
        // Check vineyard center hover
        if (findHitVineyardCenter(e.clientX, e.clientY)) {
            canvas.style.cursor = 'grab';
            return;
        }
        
        const hit = findHitControlPoint(e.clientX, e.clientY);
        hoverInfo = hit;
        if (hit) {
            canvas.style.cursor = 'grab';
            updateStatus(`Curve ${hit.cIdx}, Point ${hit.pIdx}`);
        } else {
            canvas.style.cursor = vineyardMode ? 'cell' : 'crosshair';
        }
        draw();
    }
});

canvas.addEventListener('mouseup', e => {
    if (!isInteractionActive) return;

    if (interactionType === 'DRAG_VINEYARD') {
        vineyardDragging = false;
        // Recompute vineyard if we have data
        if (vineyardData && cachedCurveData) {
            computeVineyard();
        }
    }

    if (interactionType === 'DRAG_POINT') {
        dragInfo = null;
        triggerComputation(true);
    }
    
    if (interactionType === 'POTENTIAL_PAN' && !vineyardMode) {
        saveState();
        const mousePos = screenToWorld(e.clientX, e.clientY);
        insertPointSmart(mousePos);
        updateStatus();
        triggerComputation(true);
    }

    isInteractionActive = false;
    interactionType = null;
    canvas.style.cursor = vineyardMode ? 'cell' : 'crosshair';
    draw();
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = Math.exp(e.deltaY > 0 ? -0.1 : 0.1);
    view.scale *= factor;
    draw();
}, { passive: false });

window.addEventListener('keydown', e => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        performUndo();
        return;
    }

    if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedInfo) {
            const pts = curves[selectedInfo.cIdx];
            if (selectedInfo.pIdx < pts.length) {
                saveState();
                pts.splice(selectedInfo.pIdx, 1);
                // If curve becomes empty and there are other curves, remove it
                if (pts.length === 0 && curves.length > 1) {
                    curves.splice(selectedInfo.cIdx, 1);
                    activeCurveIdx = Math.max(0, activeCurveIdx - 1);
                }
                selectedInfo = null;
                updateUI();
                updateStatus();
                triggerComputation(true);
            }
        }
    }
    
    if (e.key === 'Escape') {
        vineyardMode = false;
        updateModeIndicator();
        document.getElementById('vineyardModeBtn').classList.remove('active');
        document.getElementById('vineyardModeBtn').innerText = 'Place Center Point';
    }
});

// ========== Button Handlers ==========
document.getElementById('undoBtn').addEventListener('click', performUndo);

document.getElementById('newCurveBtn').addEventListener('click', () => {
    saveState();
    curves.push([]); // Add new empty curve
    activeCurveIdx = curves.length - 1;
    selectedInfo = null;
    updateUI();
    updateStatus(`Active: Curve ${activeCurveIdx} (New)`);
    draw();
});

document.getElementById('clearBtn').addEventListener('click', () => {
    saveState();
    curves = [[]];
    activeCurveIdx = 0;
    selectedInfo = null;
    cachedCurveData = null;
    cachedSSData = null;
    vineyardCenter = null;
    vineyardData = null;
    vineyardCenters = [];
    stopVineyardAnim();
    document.getElementById('vineyardPanel').classList.remove('active');
    document.getElementById('persistencePanel').classList.remove('active');
    updateUI();
    updateStatus('Cleared');
    draw();
});

document.getElementById('resetViewBtn').addEventListener('click', () => {
    view.x = 0; view.y = 0; view.scale = 50;
    draw();
});

document.getElementById('computeBtn').addEventListener('click', () => triggerComputation(true));

document.getElementById('presetSelect').addEventListener('change', e => {
    if (e.target.value) loadPreset(e.target.value);
});

document.getElementById('resolution').addEventListener('input', e => {
    ssResolution = parseInt(e.target.value);
    document.getElementById('resVal').innerText = ssResolution;
});

// Vineyard controls
document.getElementById('vineyardModeBtn').addEventListener('click', () => {
    vineyardMode = !vineyardMode;
    updateModeIndicator();
    const btn = document.getElementById('vineyardModeBtn');
    if (vineyardMode) {
        btn.classList.add('active');
        btn.innerText = 'Click on Canvas...';
        updateStatus('Click to place vineyard center');
    } else {
        btn.classList.remove('active');
        btn.innerText = 'Place Center Point';
    }
});

document.getElementById('vineyardRadius').addEventListener('input', e => {
    vineyardRadius = parseFloat(e.target.value);
    document.getElementById('radiusVal').innerText = vineyardRadius.toFixed(1);
    if (vineyardCenter) draw();
});

document.getElementById('vineyardSamples').addEventListener('input', e => {
    vineyardSamples = parseInt(e.target.value);
    document.getElementById('samplesVal').innerText = vineyardSamples;
});

document.getElementById('computeVineyardBtn').addEventListener('click', computeVineyard);

document.getElementById('playVineyardBtn').addEventListener('click', () => {
    if (!vineyardData) return;
    vineyardAnimPlaying = !vineyardAnimPlaying;
    document.getElementById('playVineyardBtn').innerText = vineyardAnimPlaying ? '⏸ Pause' : '▶ Play';
    if (vineyardAnimPlaying) vineyardAnimLoop();
});

document.getElementById('stopVineyardBtn').addEventListener('click', stopVineyardAnim);

document.getElementById('vineyardAnimSlider').addEventListener('input', e => {
    if (!vineyardCenters.length) return;
    const pct = parseFloat(e.target.value) / 1000;
    vineyardAnimIdx = Math.floor(pct * (vineyardCenters.length - 1));
    updatePersistenceDiagram(vineyardAnimIdx);
    updateVineyardPlot();
    draw();
});

// Visibility toggles
['showCurve', 'showControls', 'showFocal', 'showSS', 'showVineyardCircle'].forEach(id => {
    document.getElementById(id).addEventListener('change', draw);
});

document.getElementById('showVineyardPlot').addEventListener('change', e => {
    document.getElementById('vineyardPanel').classList.toggle('active', e.target.checked && vineyardData);
});

document.getElementById('showPD').addEventListener('change', e => {
    document.getElementById('persistencePanel').classList.toggle('active', e.target.checked && vineyardData);
});

// Expand/collapse vineyard panel
let vineyardExpanded = false;
document.getElementById('expandVineyardBtn').addEventListener('click', () => {
    vineyardExpanded = !vineyardExpanded;
    const panel = document.getElementById('vineyardPanel');
    const btn = document.getElementById('expandVineyardBtn');
    
    if (vineyardExpanded) {
        panel.classList.add('expanded');
        btn.innerText = '⤡ Collapse';
    } else {
        panel.classList.remove('expanded');
        btn.innerText = '⤢ Expand';
    }
    
    // Trigger resize of the plot
    setTimeout(() => {
        if (vineyardData) {
            Plotly.relayout('vineyardPlot', {
                autosize: true
            });
        }
    }, 350);
});

// Expand/collapse persistence panel
let pdExpanded = false;
document.getElementById('expandPDBtn').addEventListener('click', () => {
    pdExpanded = !pdExpanded;
    const panel = document.getElementById('persistencePanel');
    const btn = document.getElementById('expandPDBtn');
    
    if (pdExpanded) {
        panel.classList.add('expanded');
        btn.innerText = '⤡ Collapse';
    } else {
        panel.classList.remove('expanded');
        btn.innerText = '⤢ Expand';
    }
    
    // Trigger resize of the plot
    setTimeout(() => {
        if (vineyardData) {
            Plotly.relayout('persistencePlot', {
                autosize: true
            });
        }
    }, 350);
});

function stopVineyardAnim() {
    vineyardAnimPlaying = false;
    vineyardAnimIdx = 0;
    document.getElementById('playVineyardBtn').innerText = '▶ Play';
    document.getElementById('vineyardAnimSlider').value = 0;
    if (vineyardData) {
        updatePersistenceDiagram(0);
        updateVineyardPlot();
    }
    draw();
}

function vineyardAnimLoop() {
    if (!vineyardAnimPlaying || !vineyardCenters.length) return;
    
    vineyardAnimIdx = (vineyardAnimIdx + 1) % vineyardCenters.length;
    const pct = vineyardAnimIdx / vineyardCenters.length;
    document.getElementById('vineyardAnimSlider').value = Math.floor(pct * 1000);
    
    updatePersistenceDiagram(vineyardAnimIdx);
    updateVineyardPlot();
    draw();
    
    setTimeout(vineyardAnimLoop, 50);
}

// ========== Focal Animation ==========
function stopFocalAnim() {
    focalAnimPlaying = false;
    focalAnimIdx = 0;
    document.getElementById('focalPlayBtn').innerText = '▶ Play';
    document.getElementById('focalPlayBtn').style.background = 'linear-gradient(135deg, #22c55e, #16a34a)';
    document.getElementById('focalAnimSlider').value = 0;
    draw();
}

function focalAnimLoop() {
    if (!focalAnimPlaying || !cachedCurveData || cachedCurveData.length === 0) return;
    
    focalAnimIdx = (focalAnimIdx + 15) % cachedCurveData.length;
    const pct = focalAnimIdx / cachedCurveData.length;
    document.getElementById('focalAnimSlider').value = Math.floor(pct * 1000);
    
    draw();
    requestAnimationFrame(focalAnimLoop);
}

// Focal animation handlers
document.getElementById('focalPlayBtn').addEventListener('click', () => {
    if (!cachedCurveData || cachedCurveData.length === 0) return;
    
    focalAnimPlaying = !focalAnimPlaying;
    const btn = document.getElementById('focalPlayBtn');
    
    if (focalAnimPlaying) {
        btn.innerText = '⏸ Pause';
        btn.style.background = 'linear-gradient(135deg, #dc2626, #ef4444)';
        focalAnimLoop();
    } else {
        btn.innerText = '▶ Play';
        btn.style.background = 'linear-gradient(135deg, #22c55e, #16a34a)';
    }
});

document.getElementById('focalStopBtn').addEventListener('click', stopFocalAnim);

document.getElementById('focalAnimSlider').addEventListener('input', e => {
    if (!cachedCurveData || cachedCurveData.length === 0) return;
    const pct = parseFloat(e.target.value) / 1000;
    focalAnimIdx = Math.floor(pct * (cachedCurveData.length - 1));
    draw();
});

// ========== Radius Sweep ==========
function computeRadiusSweep() {
    if (!vineyardCenter || !cachedCurveData || cachedCurveData.length === 0) {
        updateStatus('Need curve and center point!');
        return;
    }
    
    updateStatus('Computing radius sweep vineyards...');
    
    const radii = [];
    for (let i = 0; i <= radiusSteps; i++) {
        radii.push(radiusStart + (radiusEnd - radiusStart) * (i / radiusSteps));
    }
    
    // Compute vineyard for each radius using the same function as single vineyard
    radiusSweepData = {
        radii: radii,
        vineyards: [],
        infinityY: 0
    };
    
    let globalInfinityY = 0;
    
    for (let rIdx = 0; rIdx < radii.length; rIdx++) {
        const r = radii[rIdx];
        
        // Use the exact same function as regular vineyard computation
        const vineyard = computeVineyardForRadius(vineyardCenter, r, vineyardSamples, cachedCurveData);
        
        radiusSweepData.vineyards.push(vineyard);
        
        if (vineyard.infinityY > globalInfinityY) {
            globalInfinityY = vineyard.infinityY;
        }
        
        // Progress update
        if (rIdx % 5 === 0) {
            updateStatus(`Computing... ${Math.round((rIdx / radii.length) * 100)}%`);
        }
    }
    
    radiusSweepData.infinityY = globalInfinityY;
    vineyardMaxVal = globalInfinityY;
    
    updateStatus(`Radius sweep done! ${radii.length} vineyards computed`);
    
    // Initialize to first radius
    radiusSweepIdx = 0;
    updateRadiusSweepDisplay();
    
    // Show panels
    document.getElementById('vineyardPanel').classList.add('active');
    document.getElementById('persistencePanel').classList.add('active');
    
    draw();
}

function updateRadiusSweepDisplay() {
    if (!radiusSweepData || !radiusSweepData.vineyards[radiusSweepIdx]) return;
    
    const currentVineyard = radiusSweepData.vineyards[radiusSweepIdx];
    const r = currentVineyard.radius;
    
    document.getElementById('currentSweepRadius').innerText = `R: ${r.toFixed(2)}`;
    
    // Update the main vineyard radius to match current sweep
    vineyardRadius = r;
    document.getElementById('vineyardRadius').value = Math.min(r, 10);
    document.getElementById('radiusVal').innerText = r.toFixed(1);
    
    // Update vineyard centers for display
    vineyardCenters = currentVineyard.centers;
    
    // Also update vineyardData so regular controls work
    vineyardData = {
        h0: currentVineyard.h0,
        h1: currentVineyard.h1,
        infinityY: currentVineyard.infinityY
    };
    vineyardMaxVal = currentVineyard.infinityY;
    
    // Update plots with current vineyard
    updateRadiusSweepVineyardPlot();
    updateRadiusSweepPersistenceDiagram();
}

function updateRadiusSweepVineyardPlot() {
    if (!radiusSweepData || !radiusSweepData.vineyards[radiusSweepIdx]) return;
    
    const currentVineyard = radiusSweepData.vineyards[radiusSweepIdx];
    const r = currentVineyard.radius;
    const maxVal = currentVineyard.infinityY;
    
    const h0 = currentVineyard.h0;
    const h1 = currentVineyard.h1;
    
    const traceH0 = {
        x: h0.map(d => d.birth),
        y: h0.map(d => d.death),
        z: h0.map(d => d.centerIdx),
        mode: 'markers',
        type: 'scatter3d',
        name: 'H₀',
        marker: {
            size: 3,
            color: '#ef4444',
            opacity: 0.7
        }
    };
    
    const traceH1 = {
        x: h1.map(d => d.birth),
        y: h1.map(d => d.death),
        z: h1.map(d => d.centerIdx),
        mode: 'markers',
        type: 'scatter3d',
        name: 'H₁',
        marker: {
            size: 3,
            color: '#3b82f6',
            opacity: 0.7,
            symbol: 'diamond'
        }
    };
    
    // Diagonal plane
    const diagPoints = {
        x: [0, maxVal, maxVal, 0],
        y: [0, maxVal, maxVal, 0],
        z: [0, 0, vineyardSamples - 1, vineyardSamples - 1],
        i: [0, 0],
        j: [1, 2],
        k: [2, 3],
        type: 'mesh3d',
        name: 'Diagonal',
        color: 'rgba(100,100,100,0.1)',
        showscale: false,
        hoverinfo: 'skip'
    };
    
    const layout = {
        scene: {
            xaxis: { 
                title: { text: 'Birth', font: { size: 11 } },
                color: '#888', 
                gridcolor: '#333',
                range: [0, maxVal],
                showspikes: false
            },
            yaxis: { 
                title: { text: 'Death', font: { size: 11 } },
                color: '#888', 
                gridcolor: '#333',
                range: [0, maxVal],
                showspikes: false
            },
            zaxis: { 
                title: { text: 'Center Idx', font: { size: 11 } },
                color: '#888', 
                gridcolor: '#333',
                range: [0, vineyardSamples - 1],
                showspikes: false
            },
            bgcolor: 'rgba(0,0,0,0)',
            camera: { eye: { x: 1.6, y: 1.6, z: 1.0 } },
            aspectmode: 'manual',
            aspectratio: { x: 1, y: 1, z: 0.8 }
        },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        margin: { l: 0, r: 0, t: 30, b: 0 },
        legend: {
            x: 0, y: 1,
            font: { color: '#ccc', size: 10 },
            bgcolor: 'rgba(0,0,0,0.5)'
        },
        showlegend: true,
        title: {
            text: `Vineyard at R = ${r.toFixed(2)}`,
            font: { color: '#c084fc', size: 13 },
            x: 0.5,
            xanchor: 'center'
        }
    };
    
    Plotly.newPlot('vineyardPlot', [diagPoints, traceH0, traceH1], layout, {
        displayModeBar: false,
        responsive: true
    });
}

function updateRadiusSweepPersistenceDiagram() {
    if (!radiusSweepData || !radiusSweepData.vineyards[radiusSweepIdx]) return;
    
    const currentVineyard = radiusSweepData.vineyards[radiusSweepIdx];
    const r = currentVineyard.radius;
    const maxVal = currentVineyard.infinityY;
    
    // Aggregate all points for this vineyard into one PD
    const h0 = currentVineyard.h0;
    const h1 = currentVineyard.h1;
    
    const traceH0 = {
        x: h0.map(d => d.birth),
        y: h0.map(d => d.death),
        mode: 'markers',
        type: 'scatter',
        name: 'H₀',
        marker: { size: 8, color: '#ef4444', symbol: 'circle', opacity: 0.6 }
    };
    
    const traceH1 = {
        x: h1.map(d => d.birth),
        y: h1.map(d => d.death),
        mode: 'markers',
        type: 'scatter',
        name: 'H₁',
        marker: { size: 8, color: '#3b82f6', symbol: 'triangle-up', opacity: 0.6 }
    };
    
    const diagonal = {
        x: [0, maxVal],
        y: [0, maxVal],
        mode: 'lines',
        type: 'scatter',
        name: 'Diagonal',
        line: { color: '#555', dash: 'dash', width: 1 },
        showlegend: false,
        hoverinfo: 'skip'
    };
    
    const infinityLine = {
        x: [0, maxVal],
        y: [currentVineyard.infinityY, currentVineyard.infinityY],
        mode: 'lines',
        type: 'scatter',
        name: '∞',
        line: { color: '#888', dash: 'dot', width: 1 },
        showlegend: false,
        hoverinfo: 'skip'
    };
    
    const layout = {
        xaxis: { 
            title: { text: 'Birth', font: { size: 12, color: '#aaa' }, standoff: 10 },
            color: '#888', 
            gridcolor: '#333',
            range: [-maxVal * 0.02, maxVal * 1.02],
            zeroline: true,
            zerolinecolor: '#666',
            zerolinewidth: 2,
            showline: true,
            linecolor: '#666',
            linewidth: 1,
            tickmode: 'auto',
            nticks: 8
        },
        yaxis: { 
            title: { text: 'Death', font: { size: 12, color: '#aaa' }, standoff: 10 },
            color: '#888', 
            gridcolor: '#333',
            range: [-maxVal * 0.02, maxVal * 1.02],
            zeroline: true,
            zerolinecolor: '#666',
            zerolinewidth: 2,
            showline: true,
            linecolor: '#666',
            linewidth: 1,
            scaleanchor: 'x',
            scaleratio: 1,
            tickmode: 'auto',
            nticks: 8
        },
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(10,10,15,0.5)',
        margin: { l: 60, r: 20, t: 40, b: 55 },
        legend: {
            x: 0.75, y: 0.15,
            font: { color: '#ccc', size: 11 },
            bgcolor: 'rgba(0,0,0,0.6)',
            bordercolor: 'rgba(255,255,255,0.1)',
            borderwidth: 1
        },
        showlegend: true,
        title: {
            text: `All PDs at R = ${r.toFixed(2)}`,
            font: { color: '#aaa', size: 13 },
            x: 0.5,
            xanchor: 'center'
        },
        annotations: [{
            x: maxVal * 0.02,
            y: currentVineyard.infinityY,
            xref: 'x',
            yref: 'y',
            text: '∞',
            showarrow: false,
            font: { color: '#888', size: 12 },
            xanchor: 'left',
            yanchor: 'middle'
        }]
    };
    
    Plotly.newPlot('persistencePlot', [diagonal, infinityLine, traceH0, traceH1], layout, {
        displayModeBar: false,
        responsive: true
    });
}

function stopRadiusSweep() {
    radiusSweepPlaying = false;
    document.getElementById('playRadiusSweepBtn').innerText = '▶ Play Sweep';
    document.getElementById('playRadiusSweepBtn').style.background = '';
}

function radiusSweepAnimLoop() {
    if (!radiusSweepPlaying || !radiusSweepData) return;
    
    radiusSweepIdx = (radiusSweepIdx + 1) % radiusSweepData.radii.length;
    const pct = radiusSweepIdx / (radiusSweepData.radii.length - 1);
    document.getElementById('radiusSweepSlider').value = Math.floor(pct * 1000);
    
    updateRadiusSweepDisplay();
    draw();
    
    setTimeout(radiusSweepAnimLoop, 200);
}

// Radius sweep event handlers
document.getElementById('radiusStart').addEventListener('input', e => {
    radiusStart = parseFloat(e.target.value);
    document.getElementById('radiusStartVal').innerText = radiusStart.toFixed(1);
});

document.getElementById('radiusEnd').addEventListener('input', e => {
    radiusEnd = parseFloat(e.target.value);
    document.getElementById('radiusEndVal').innerText = radiusEnd.toFixed(1);
});

document.getElementById('radiusSteps').addEventListener('input', e => {
    radiusSteps = parseInt(e.target.value);
    document.getElementById('radiusStepsVal').innerText = radiusSteps;
});

document.getElementById('computeRadiusSweepBtn').addEventListener('click', computeRadiusSweep);

document.getElementById('playRadiusSweepBtn').addEventListener('click', () => {
    if (!radiusSweepData) return;
    
    radiusSweepPlaying = !radiusSweepPlaying;
    const btn = document.getElementById('playRadiusSweepBtn');
    
    if (radiusSweepPlaying) {
        btn.innerText = '⏸ Pause';
        btn.style.background = 'linear-gradient(135deg, #dc2626, #ef4444)';
        radiusSweepAnimLoop();
    } else {
        btn.innerText = '▶ Play Sweep';
        btn.style.background = '';
    }
});

document.getElementById('stopRadiusSweepBtn').addEventListener('click', () => {
    stopRadiusSweep();
    radiusSweepIdx = 0;
    document.getElementById('radiusSweepSlider').value = 0;
    if (radiusSweepData) {
        updateRadiusSweepDisplay();
        draw();
    }
});

document.getElementById('radiusSweepSlider').addEventListener('input', e => {
    if (!radiusSweepData) return;
    const pct = parseFloat(e.target.value) / 1000;
    radiusSweepIdx = Math.floor(pct * (radiusSweepData.radii.length - 1));
    updateRadiusSweepDisplay();
    draw();
});

// ========== Vineyard Center Dragging ==========
function findHitVineyardCenter(sx, sy) {
    if (!vineyardCenter) return false;
    const sp = worldToScreen(vineyardCenter);
    const dx = sp.x - sx, dy = sp.y - sy;
    return dx*dx + dy*dy < 200; // Slightly larger hit area
}

// ========== Computation ==========
let computeTimer = null;
function triggerComputation(fullCompute = true) {
    // Check if any curve has at least 3 points
    const hasValidCurve = curves.some(c => c.length >= 3);
    if (!hasValidCurve) { draw(); return; }
    
    if (!fullCompute) {
        cachedCurveData = computeSplineData();
        cachedSSData = null;
        draw();
        return;
    }

    if (computeTimer) clearTimeout(computeTimer);
    
    computeTimer = setTimeout(() => {
        cachedCurveData = computeSplineData();
        cachedSSData = computeSymmetrySet(cachedCurveData, ssResolution);
        updateStatus(`SS: ${cachedSSData.length} points`);
        draw();
    }, 10);
}

// ========== Drawing ==========
function draw() {
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.translate(canvas.width / 2 + view.x, canvas.height / 2 + view.y);
    ctx.scale(view.scale, -view.scale);
    
    // Grid
    ctx.strokeStyle = '#1a1a2e';
    ctx.lineWidth = 1 / view.scale;
    ctx.beginPath();
    ctx.moveTo(-1000, 0); ctx.lineTo(1000, 0);
    ctx.moveTo(0, -1000); ctx.lineTo(0, 1000);
    ctx.stroke();

    if (cachedCurveData && cachedCurveData.length > 0) {
        // Focal set
        if (document.getElementById('showFocal').checked) {
            ctx.fillStyle = '#22c55e';
            const s = 1.5 / view.scale;
            for (const pt of cachedCurveData) {
                const k = pt.curvature;
                if (Math.abs(k) > 1e-8) {
                    const R = 1.0 / k;
                    if (Math.abs(R) < R_MAX) {
                        const ex = pt.p.x + pt.N.x * R;
                        const ey = pt.p.y + pt.N.y * R;
                        ctx.fillRect(ex - s/2, ey - s/2, s, s);
                    }
                }
            }
        }

        // Symmetry set
        if (document.getElementById('showSS').checked && cachedSSData) {
            ctx.fillStyle = '#ef4444';
            const s = 1.5 / view.scale;
            for (const p of cachedSSData) {
                ctx.fillRect(p.x - s/2, p.y - s/2, s, s);
            }
        }

        // Curve - draw each curve separately
        if (document.getElementById('showCurve').checked) {
            ctx.strokeStyle = '#4f8cff';
            ctx.lineWidth = 2.5 / view.scale;
            
            // Group points by curveId and draw each as separate path
            let currentId = -1;
            ctx.beginPath();
            
            for (let i = 0; i < cachedCurveData.length; i++) {
                const pt = cachedCurveData[i];
                if (pt.curveId !== currentId) {
                    // Close previous path if exists
                    if (currentId !== -1) {
                        ctx.closePath();
                        ctx.stroke();
                        ctx.beginPath();
                    }
                    ctx.moveTo(pt.p.x, pt.p.y);
                    currentId = pt.curveId;
                } else {
                    ctx.lineTo(pt.p.x, pt.p.y);
                }
            }
            // Close and stroke the last curve
            if (currentId !== -1) {
                ctx.closePath();
                ctx.stroke();
            }
        }
        
        // Focal animation visualization
        if ((focalAnimPlaying || focalAnimIdx > 0) && focalAnimIdx < cachedCurveData.length) {
            const pt = cachedCurveData[focalAnimIdx];
            
            ctx.save();
            ctx.strokeStyle = '#fcd34d';
            ctx.fillStyle = '#fcd34d';
            ctx.lineWidth = 2 / view.scale;
            
            // Point on curve
            const s = 10 / view.scale;
            ctx.beginPath();
            ctx.arc(pt.p.x, pt.p.y, s/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw osculating circle
            const k = pt.curvature;
            if (Math.abs(k) > 1e-8) {
                const R = 1.0 / k;
                if (Math.abs(R) < R_MAX) {
                    const ex = pt.p.x + pt.N.x * R;
                    const ey = pt.p.y + pt.N.y * R;
                    
                    // Center of curvature
                    ctx.beginPath();
                    ctx.arc(ex, ey, s/2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Line from point to center
                    ctx.beginPath();
                    ctx.moveTo(pt.p.x, pt.p.y);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                    
                    // Osculating circle
                    ctx.strokeStyle = 'rgba(253, 224, 71, 0.4)';
                    ctx.lineWidth = 1.5 / view.scale;
                    ctx.beginPath();
                    ctx.arc(ex, ey, Math.abs(R), 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }
    }

    // Vineyard visualization
    if (document.getElementById('showVineyardCircle').checked) {
        // Vineyard center
        if (vineyardCenter) {
            ctx.fillStyle = '#a855f7';
            ctx.beginPath();
            ctx.arc(vineyardCenter.x, vineyardCenter.y, 6 / view.scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Circle preview
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.5)';
            ctx.lineWidth = 1.5 / view.scale;
            ctx.setLineDash([5 / view.scale, 5 / view.scale]);
            ctx.beginPath();
            ctx.arc(vineyardCenter.x, vineyardCenter.y, vineyardRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Vineyard sample centers
        if (vineyardCenters.length > 0) {
            ctx.fillStyle = 'rgba(168, 85, 247, 0.4)';
            const s = 3 / view.scale;
            for (let i = 0; i < vineyardCenters.length; i++) {
                const c = vineyardCenters[i];
                ctx.fillRect(c.x - s/2, c.y - s/2, s, s);
            }
            
            // Current animated center
            if (vineyardAnimIdx < vineyardCenters.length) {
                const curr = vineyardCenters[vineyardAnimIdx];
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath();
                ctx.arc(curr.x, curr.y, 8 / view.scale, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw radial lines to curve (subliminal visualization)
                if (cachedCurveData && cachedCurveData.length > 0) {
                    ctx.strokeStyle = 'rgba(251, 191, 36, 0.15)';
                    ctx.lineWidth = 0.5 / view.scale;
                    const step = Math.max(1, Math.floor(cachedCurveData.length / 50));
                    for (let i = 0; i < cachedCurveData.length; i += step) {
                        ctx.beginPath();
                        ctx.moveTo(curr.x, curr.y);
                        ctx.lineTo(cachedCurveData[i].p.x, cachedCurveData[i].p.y);
                        ctx.stroke();
                    }
                }
            }
        }
    }

    // Control points
    if (document.getElementById('showControls').checked) {
        const baseSize = 7 / view.scale;
        const hoverSize = 10 / view.scale;
        
        for (let c = 0; c < curves.length; c++) {
            const pts = curves[c];
            for (let i = 0; i < pts.length; i++) {
                const p = pts[i];
                const isHover = (hoverInfo && hoverInfo.cIdx === c && hoverInfo.pIdx === i) || 
                               (dragInfo && dragInfo.cIdx === c && dragInfo.pIdx === i);
                const isSelected = (selectedInfo && selectedInfo.cIdx === c && selectedInfo.pIdx === i);
                const isActiveCurve = (c === activeCurveIdx);
                
                if (isSelected) ctx.fillStyle = '#4f8cff';
                else if (isHover) ctx.fillStyle = '#fbbf24';
                else ctx.fillStyle = isActiveCurve ? '#fff' : '#666'; // Dim inactive curves

                const s = (isHover || isSelected) ? hoverSize : baseSize;
                ctx.fillRect(p.x - s/2, p.y - s/2, s, s);
                
                if (isSelected) {
                    ctx.strokeStyle = '#4f8cff';
                    ctx.lineWidth = 1.5 / view.scale;
                    ctx.strokeRect(p.x - s/2 - 2/view.scale, p.y - s/2 - 2/view.scale, s + 4/view.scale, s + 4/view.scale);
                }
            }
        }
    }
    
    ctx.restore();
}

// ========== Resize ==========
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    draw();
}
window.addEventListener('resize', resize);
resize();

// Initial status
updateStatus('Click to add points or load a preset');
</script>
</body>
</html>